**Паттерны 

Паттерн – это часто распространённой определённой проблемы при проектировании  архитектуры программ. 

Часто паттерны путают с алгоритмами, но алгоритм — это чёткий набор действий, а  паттерн — это описание решения (некий чертёж) который может отличатся от программы к  программе.  

Паттерн состоит из: 

- проблемы которую он решает 

- мотивацию к решению проблемы способом, который он предлагает 

- структура классов(схем), которые включены в решение 

- особенности реализации в различных контекстах 

- связей с другими классами  

Паттерны бывают: 

1) Паттерны поведения – решают задачи эффективного и безопасного взаимодействия  между объектами программы. 

2) Порождающие паттерны – отвечают за удобное и безопасное создание новых объектов  или даже целых семейств объектов. 

3) Структурные паттерны – отвечают за построение удобных в поддержке иерархий  классов.

1 

Паттерны поведения 

Стратегия - стратегия инкапсулирует определенное поведение с возможностью его  подмены. 

Каждый раз когда мы используем наследование, когда абстрагируемся от некоторого  процесса или поведения мы используем стратегию за базовым классом или интерфейсом мы  используем стратегию. 

Пример: сортировка, анализ данных, валидация, социализация, получение конфигурации  – должны быть выражены в виде стратегии.  

Применяется в случаях: 

- инкапсулировать поведение или алгоритм 

- замена поведения или алгоритма во время использования 

Заметки:  

- любой класс уже инкапсулирует поведение, но стратегия надо не просто спрятать  поведения или алгоритм, а иметь возможность его подменить в процессе.  - стратегия является некой точкой расширения в приложении  

- перед применением стратегии стоит понимать нужна ли она на данном этапе и будем  мы что-то подменять.  

- наследование добавляет гибкости, однако увеличивает сложность 

- [[LINQ]] - это набор методов расширения, принимающих стратегии фильтрации,  получения проекции и т. д. Коллекции принимают стратегии сравнения элементов, а значит,  любой класс, который принимает IComparer<T> или IEqualityComparer<T>, использует  паттерн «Стратегия». 

Плюсы: 

- изолирует поведение и алгоритмы от других классов 

- подмена в процессе работы  

- реализует принцип открытости/закрытости  

Минусы: 

- усложняет программу засечёт дополнительных классов 

- клиент должен знать, в чём состоит разница между стратегиями, чтобы выбрать  подходящую.  

Мой личный пример на проекте(Стратегия):  

Данные о визитах пациентах должны отправляется на агрегаторы которые передают  данные страховым компаниям. Одним из таких есть Sandata и Change Healthcare, отличие  между ними в разных страховых компаниях которые они обслуживают, но при этом  некоторые страховые компании обслуживались в обоих агрегаторах и в зависимости от  некоторых условий должны в процессе определять кому отправлять. Типичный пример  стратегии. Я реализовал стратегию через интерфейс, сервисы которые отвечали за 

2 

формирование данных для запросов на отправку этим агрегаторам имплементировали этот  интерфейс и в зависимости от условий в процессе изменялась стратегия.  

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXcj0-FR3DgSAA1Jyo9VfotZ4w2EHzYV6M2hrjjFZAqhEBxN7whNNBo1KANWJYveqiu7hDBjJ6kfmqH_bXj0VOaqqJtqLOZhP8grFt2F6AVtJfkrDTd7kTkHZuWipiljIPPw5gt_Mx9Gc3xtjgLxwydm7Tt-?key=yjRwXb7PJrHg8pl5IhCOAA)

Итератор - даёт возможность последовательно обходить элементы составных  объектов, не раскрывая их внутреннего представления. 

Большинство коллекций это обычный список элементов, но есть такие коллекции как  дерево, граф и ид. При этом надо иметь возможность обходить любую коллекцию и разными  вариантами. В данном случае поможет Итератор. 

Суть вынести поведение обхода коллекции из самой коллекции в отдельный класс.  Объект итератора должен отслеживать состояние обхода, текущую позицию и сколько  элементов осталось ещё обойти. 

Таким образом к примеру если нам надо обойти дерево разными способами(в ширь или  в глубину) можно реализовать свой алгоритм обхода коллекции используя итератор, а  итератор должен сам отслеживать текущую позицию чтобы другие итераторы могли обходить  одну и туже позицию.  

В общем случае не создаются итераторы, а получаются из коллекции. 

Когда использовать: 

- когда у нас сложная структура данных 

- когда нам нужно несколько вариантов одной и той же структуры  

Плюсы: 

- позволяет реализовывать различные способы обхода структуры данных - позволяет одновременно делать обход разными способами  

Минусы: 

- не имеет смысла, если можно обойтись обычным циклом 

В .NET итераторы(есть обобщенные и не обобщенные) являются однонаправленными только  для чтения. Для получения итератора используется GetEnumerator интерфейса IEnumerable  и возвращает тип IEnumerator который состоит из методов и переменой: 

MoveNext – переход на следующую позицию возвращает false если конец  последовательности  

Current(тип object) – возвращает текущий элемент 

Reset – возвещает к началу агрегата. И реализуется не всегда, потому что если итератор  возвращае данные из сети в этом случае reset не используется.

3 

В .NET foreach является универсальным инструментом для обработки (обобщённых и не  обобщенных) коллекций последовательностей. 

Реализация foreach под капотом 

public static void ForEachIEnumerable(IEnumerable sequence) 

 { 

 // foreach(var e in sequence) {Console.WriteLine(e);} 

 IEnumerator enumerator = sequence.GetEnumerator(); 

 try 

 { 

 while (enumerator.MoveNext()) 

{ 

 Console.WriteLine(enumerator.Current); 

 } 

 } 

 finally 

 { 

 IDisposable disposable = enumerator as IDisposable; 

 if (disposable != null) 

 { 

 disposable.Dispose(); 

 } 

 } 

 } 

Любой итератор использует IDisposable. IEnumerator наследует IDisposable потому что  итераторы могут содержать ресурсы которые надо очистить в блоке finally  ![](https://lh7-us.googleusercontent.com/docsz/AD_4nXdZ1xPlZpDaycESjMWWTW1PhVVo3fDwDnSrytCbTlXqKFPypeNIkFIfxsjevmsO9oPqrrTOyTMqa4slOZDuSAsALkwL_r4L1ajn7cJpJxN9Onu5j0N418LwF6vTvlHnNWpcPQYCZkszZ3rU8ibuR7xbO_Nn?key=yjRwXb7PJrHg8pl5IhCOAA)

Наблюдатель(Observer) - позволяет объектам оповещать другие объекты об изменениях  своего состояния. 

В .NET существует 4 варианта реализации этого паттерна 

- с помощью делегатов (методов обратного вызова) 

- с помощью событий  

- с помощью специальных интерфейсов наблюдателей  

- с помощью интерфейсов IObserver/ IObservable

4 

Первый способ самый простой и требует только принятия делегата в аргументах конструктора  + подходит когда надо вернуть некий результат  

- подходит только 1:1 

Используем: 

1) Наблюдатель должен быть обязательно  

2) Наблюдатель ожидает результата 

Не используем: 

1) Когда большое число делегатов  

2) Для повторно используемых компонентов  

3) Когда передаётся поток событий  

Второй способ это реализация Наблюдателя с коробки  

+ любое количество подписчиков смогут подписаться  

- нет гарантии, что они вообще будут  

Используем: 

1) Для повторно используемых компонентов  

2) Для отправки множеству наблюдателей 

Не используем: 

1) Когда наблюдателю нужно получить результат  

Третий способ более похож на классический Наблюдатель. Предаётся интерфейс в  конструктор 

+ подходит когда надо вернуть некий результат  

- подходит только 1:1 

Используем: 

1) Когда нужно разные реакции на событие  

Не используем: 

2) В открытом API 

Долгоживущие наблюдаемые объекты являются наиболее распространенной причиной  утечки памяти в .NET-приложениях 

Решение: 

- избегать долгоживущих объектов вообще, а долгоживущих объектов с событиями — в  особенности. 

- реализовать интерфейс IDisposable и отписываться от событий в методе Dispose. 

Плюсы: 

- издатель не зависит от подписчиков и наоборот  

- подписка/отписка 

- реализует принцип открытости/закрытости  

Минусы:

5 

- подписчики уведомляются в случайном порядке 

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXfaeI3RZtywmniN_muTLFgosiyZMfe976PNvX2jDAh6Bpr4u5VsD_v3dB4vHRmIq2qaYQdob95hLoVb1POe6zyncx1IQIwQ0RCfxwC9ZTBQ9_gG__LxdskP6XVoykPeqG86vRwM1u8-74oebLVZK_EGeco?key=yjRwXb7PJrHg8pl5IhCOAA)

Порождающие паттерны 

Одиночка(Singleton) - гарантирует, что у класса есть только один экземпляр, и  предоставляет глобальную точку доступа к нему. Эмулирует глобальные переменные. 

«Синглтон» обычно используется для обеспечения доступа к какому-либо ресурсу, который  требуется разным частям приложения. 

Требования: 

- доступ в многопоточной среде 

- «ленивость» создания синглтона  

public sealed class LazySingleton 

{ 

 private static readonly Lazy<LazySingleton> _instance = 

 new Lazy<LazySingleton>(() => new LazySingleton()); 

 LazySingleton() { } 

 public static LazySingleton Instance { get { return _instance.Value; } } 

} 

Достоинства данного кода: простота + потокобезопасность + «ленивость» Минусы данного кода: доступна с .NET 4.0+ 

Главными недостатками синглтонов считаются невозможность юнит-тестирования классов,  которые пользуются услугами синглтона, и низкая гибкость. Код ниже возвращает не  конкретный класс. 

public class GlobalLogger 

{ 

 private static ILogger _logger = new DefaultLogger(); 

 // Классы этой сборки (или друзья) смогут задать 

 // нужный экземпляр логера 

 public static ILogger Logger

6 

 { 

 get { return _logger; } 

 internal set { _logger = value; } 

 } 

} 

При отсутствии состояния и наличии небольшого числа операций статические методы  являются более подходящим решением. Если же глобальный объект обладает состоянием, то  реализация на основе паттерна «Синглтон» будет проще 

Главная же проблема паттерна «Синглтон» заключается в том, что синглтон по своему  определению является глобальной переменной со всеми ее недостатками. - Необходимость конструктора по умолчанию 

- Неявные зависимости 

- Состояние. Синглтон с изменчивым состоянием является источником очень коварных  ошибок. 

Нормальный Синглтон: 

1) Синглтон без видимого состояния. Нет ничего смертельного в использовании синглтона,  через который можно получить доступ к стабильной справочной информации или  некоторым утилитам 

2) Настраиваемый контекст. Аналогично нет ничего смертельного в протаскивании  инфраструктурных зависимостей в виде Ambient Context, то есть в использовании  синглтона, возвращающего абстрактный класс или интерфейс, который можно установить  в начале приложения или при инициализации юнит-теста. 

3) Минимальная область использования. Ограничьте использование синглтона минимальным  числом классов/модулей 

Плюсы: 

- гарантирует наличие единственного экземпляра класса 

- предоставляет к нему глобальную точку доступа- реализует принцип  открытости/закрытости  

- реализует отложенную инициализацию объекта-одиночки. (для статических стразу  выделяется) 

- неявное использование при передачи как параметр метода 

Минусы: 

- нарушает принцип единственной ответственности класса (он не только выполняет свою  основную функцию, но и контролирует количество связных элементов)  - маскирует плохой дизайн 

- требует постоянного создания Mock-объектов при юнит-тестировании - проблемы мультипоточности. 

- повышает связность 

7 

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXd7z7wWPvPxSJnAtPcnInvEw2JjlrNFkVNQmRVcNi1co-iF_-OP7lLXY904VBylYQ6S97mzzXAXlm7r-EB3eD7LhexFc02P8NUinkSdU-46k_E02YtHDOmdA-uLtoocDWR2KV3gPjK_sfWtA36eQBc3cN_J?key=yjRwXb7PJrHg8pl5IhCOAA)

Абстрактная фабрика (Abstract Factory) - позволяет создавать семейства связанных  объектов, не привязываясь к конкретным классам создаваемых объектов. 

Если возникает необходимость создания группы объектов разными способами можно  реализовать интерфейс абстрактной фабрики имплементировать его в разные фабрики-классы  и в зависимости от условий вызывать конкретную фабрику. 

Применимость: 

- когда бизнес-логика программы должна работать с разными видами связанных друг с  другом продуктов, не завися от конкретных классов продуктов. 

- когда в программе уже используется Фабричный метод, но очередные изменения  предполагают введение новых типов продуктов. 

Заметка: 

Абстрактная фабрика скрывает от клиентского кода подробности того, как и какие конкретно  объекты будут созданы. Но при этом клиентский код может работать со всеми типами  создаваемых продуктов, поскольку их общий интерфейс был заранее определён. 

Плюсы: 

- гарантирует сочетаемость создаваемых продуктов. 

- реализует принцип открытости/закрытости. - реализует отложенную  инициализацию объекта-одиночки. 

 - избавляет клиентский код от привязки к конкретным классам продуктов - упрощает добавление новых продуктов в программу 

Минусы: 

- усложняет код программы из-за введения множества дополнительных классов. - маскирует плохой дизайн 

- требует наличия всех типов продуктов в каждой вариации. 

Мой личный пример на проекте(Abstract Factory): 

8 

При первой регистрации стафф заполняет карточку пациента и выбирает тип пакета лечения  который будет предоставлен пациенту, после создания пациента будут созданы документы  которые относятся к началу лечения их около 10 и их количество может меняться. Service  Agreement(Соглашение об обслуживании), Disaster Classification(Классификация бедствий – тяжесть состояние пациента), Rights Of Patients(Права пациентов) я реализовал фабрику  которая в зависимости от типа услуги будет создавать эти документы, каждый тип услуги  имеет свою фабрику реализации создания этих документов и в процессе определяется какую  фабрику лучше использовать.  

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXcS1HxorPVQ6TjgvgFS9flCg_6ztey3b8Ka16uWjku_n62JpLwbTnTAjvk_CASPbflLhBcs0dMk00XMgBc6zwJ-LbrpkMa9lXyZb9-vKO11puYGDsT2NOE8NTbPXlrork6DkLjU0dtOmTXh12uL0_ptNMw?key=yjRwXb7PJrHg8pl5IhCOAA)

Фабричный метод (Factory Method) - определяет общий интерфейс для создания  объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов. 

Применимость: 

- когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш  код. 

- когда вы хотите дать возможность пользователям расширять части вашего фреймворка или  библиотеки. 

- когда вы хотите экономить системные ресурсы, повторно используя уже созданные  объекты, вместо порождения новых. 

Плюсы: 

- реализует принцип открытости/закрытости. 

- выделяет код производства продуктов в одно место, упрощая поддержку кода. - избавляет класс от привязки к конкретным классам продуктов. 

- упрощает добавление новых продуктов в программу. 

Минусы: 

- может привести к созданию больших параллельных иерархий классов, так как для каждого  класса продукта надо создать свой подкласс создателя.

9 

Мой пример выдуманный: 

У нас есть филиал банка, где клиент может открыть 3 вида счёта в этом банке, пускай это  будет ПЕРСОНАЛЬНЫЙ, БИЗНЕС и ПРЕМИУМ это классы которые будут  имплементировать интерфейс БАНКА-АККАУН. И в классе ФИЛИАЛ будет метод создания  счёта который принимает тип счёта и возвращать интерфейс БАНКА-АККАУН 

Первая проблема будет нам надо будет дублировать if-else или свитч во всех местах, где  делаются такие же действия  

Вторая проблема возникнет когда мы добавим новый вид счёта нам надо будет менять код в  клиенте в методе открытия счёта и во всех других местах  

Третья проблема это то что наш класс ФИЛИАЛ будет связан со всеми классами банковских  счетов. С увеличением количества новых счетов будет увеличивается зависимость  

Решение данной проблемы будет применение Фабричного метода  

Мы можем создать класс БАНК_АККАУНТ_ФАКТОРИ и вынести туда метод создания  банковского счёта и далее филиал будет принимать в конструкторе фабрику создания счёта Но при этом если нет необходимости в изменении создания счёта от каких-то условий это  будет больше похожу на метод ПРОСТАЯ ФАБРИКА. 

Но если мы представим, что наш филиал который работаем в другой стране он создаёт счета  по другому условию и теперь нам надо сделать наш класс БАНК_АККАУНТ_ФАКТОРИ  абстрактным и метод создания фабрики, далее создать два наследника  ЛОКАЛ_БАНК_АККАУНТ_ФАКТОРИ и ФОРИНДЖ_БАНК_АККАУНТ_ФАКТОРИ  унаследовать БАНК_АККАУНТ_ФАКТОРИ и переопределить метода создания  

Теперь в конструктор филиала мы передаём конкретную фабрику создания счёта и уже в её  переопределенный метод передаём тип счёта. 

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXfCsqrk_iY9kz5N-hE-tS3oUGTeKOAByH8O2dyRogr_WpFpjU630vakQe8e3Lf0IeIB9U8d9hb3AWsChMeGVDHuvqmzj86gz0E29G9MLqGioBi1cWnbIyhAfxzNfKGUuwCqk_x8Jbq64hEh11ImMaAVTuEj?key=yjRwXb7PJrHg8pl5IhCOAA)10 

Строитель (Builder) - позволяет создавать сложные объекты пошагово. Строитель даёт  возможность использовать один и тот же код строительства для получения разных  представлений объектов. 

Иногда процесс создания является довольно сложным, состоит из нескольких этапов.  Создаваемому объекту нужно передать множества аргументов, часть из которых нужны  одним клиентам, но не нужны другим. В этом случае фабричный метод с десятью  аргументами, девять из которых будут регулярно повторяться, нельзя назвать удачным  решением. В этом случае поможет другой порождающий паттерн — «Строитель» 

Применимость: 

- когда вы хотите избавиться от «телескопического конструктора» 

- когда вам нужно собирать сложные составные объекты 

Плюсы: 

- позволяет создавать продукты пошагово. 

- позволяет использовать один и тот же код для создания различных продуктов. - изолирует сложный код сборки продукта от его основной бизнес-логики. 

Минусы: 

- усложняет код программы из-за введения дополнительных классов 

Мой личный пример на проекте(Builder):  

В приложении была необходимость создания отчёта о выполненных скедлах для отправки их  на агрегатор. Для сандаты отчёт состоял из визитов к пациенту за определённый период  времени. Сам класс отчёта состоял из множества полей обязательных и не обязательных и в  зависимости от ряда факторов одни из них добавлялись в отчёт другие нет. Каждый из  агрегаторов принимал свой отчёт, но так же содержали общие данные. Я создал абстрактный  класс АГРЕГАТОР_РЕПОРТ_БИЛДЕР где добавил абстрактный метод билд и общие поля  вынес туда. Далее перед созданием отчёта вызывался билдер для конкретного отчёта и  формировался объект.

11 

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXcG608VPXkhqWSFEHANMVCDVg4aBTAX8BY21Rp1yTCtpMPFl5AcJDZUdpnVvVH64611aB3zS48onQ2BHKO_E4GygjwJ7iB39ovNYz052-fAW2iW62BJAf9ZI4OJEdu-xLT4dHVfuh65UpY4EWEy2Wzy5FUr?key=yjRwXb7PJrHg8pl5IhCOAA)

Структурные паттерны 

Декоратор (Decorator) - динамически добавляет объекту новые обязанности. Является  гибкой альтернативой порождению подклассов с целью расширения функциональности.  Обёртка или враппер. 

Применимость: 

- кеширование результатов работы 

- замеры времени использования методов 

- легирование аргументов  

- управление доступом пользователей  

- модификация аргументов или результатов работы метода упаковки/распаковки,  шифрования  

Спорный момент можно ли называть атрибуты в .NET декоратором  

Плюсы: 

- позволяет добавлять обязанности на лету 

- можно добавлять несколько новых обязанностей сразу

12 

Минусы: 

- чувствительность к порядку. Код инициализации декораторов очень важен, поскольку  именно в процессе создания определяются вложенность и порядок исполнения разных  декораторов. 

- обилие крошечных классов. 

Мой пример выдуманный: 

Представим что у нас есть интерфейс с методом отправки уведомления пользователю, и класс  смс который имплементирует этот интерфейс, далее появилась необходимость добавить  отправку по почте и в телеграмм. Но со временем появилась необходимость отправки  уведомления сразу всем или комбинировано.  

Наследование — это первое, что приходит в голову, когда нужно расширить какое-то  существующее поведение. Но механизм наследования имеет несколько проблем.   - Он статичен. Вы не можете изменить поведение существующего объекта. Для этого вам  надо создать новый объект, выбрав другой подкласс.  

- Он не разрешает наследовать поведение нескольких классов одновременно. Из-за этого вам  приходится создавать множество подклассов-комбинаций для получения совмещённого  поведения 

Решение: замена наследования агрегацией либо композицией . Это когда один объект  содержит ссылку на другой и делегирует ему работу, вместо того чтобы самому наследовать  его поведение. Как раз на этом принципе построен паттерн Декоратор 

Мы создаём абстрактный класс БАЗОВЫЙ_ДЕКОРАТОР_УВИДОМЛЕНИЯ наследуемся он  интерфейса в конструкторе принимаем объект интерфейста и присваиваем переменной класса  Создаём виртуальный метод отправки(чтобы упростить расширение классов и наследники  могли использовать реализацию базового класса) и делаем декораторы наследники  ТЕЛГРАММ_ДЕКОРАТОР, СМС_ДЕКОРАТОР, ЕМАИЛ_ДЕКОРАТОР которые  

наследуют класс БАЗОВЫЙ_ДЕКОРАТОР_УВИДОМЛЕНИЯ используем base для общения  с конструктором базового класса  

Теперь мы можем создать переменную класса конкретного компонента отправки и передавать  его в качестве параметра во все декораторы которые реализуют такой же инструмент как и он.  Теперь мы можешь расширять декораторы 

13 

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXfSWaLs0Y8nwBz0YzNbDgUf9B6CCw2zkpuPAgduzcNVjGwPfJvcztqbjm2KagwRcS9QErBZA6IXf7G4JRevS9w8Iz0zfu61M3U-vTWzBVdyVFtdfeT1Z2vmQv1iIt1c0wA7nbuVh9A6cSfOIhS6UNcrEYTz?key=yjRwXb7PJrHg8pl5IhCOAA)

Заместитель (Proxy) - который позволяет подставлять вместо реальных объектов  специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному  объекту, позволяя сделать что-то до или после передачи вызова оригиналу. 

Если на ранних этапах некая операция выполнялась на стороне клиента или же приложение  состояло из одного процесса, то со временем исполнение операции может быть перенесено на  сервер, а приложение разбито на несколько процессов. В результате возникает задача  взаимодействия с удаленным процессом, реализация которой должна быть максимально  похожей на локальное взаимодействие 

Отличие от декоратора  

Класс-заместитель может выполнять определенные действия, например создавать настоящий  компонент по мере необходимости, но он не должен ничего подмешивать в результаты  исполнения операции 

Класс Lazy<T> можно считать универсальным строительным блоком, с помощью которого  легко создавать виртуальные классы-заместители

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXeIewZ-ej81q02HzTwLJ7eJ_75TTXkDndnoEJ1GDSxxGe0gmfMl8DQS9PERRGeFkabb-xkqpfWO8nxhHw_4LNwU5UfjbUvDO7-5WiOeYNYoZIZSjis1k-HRARMEKKoXr6y5vxPFJs71aV_UAIu0OaIjYaee?key=yjRwXb7PJrHg8pl5IhCOAA)14 

Применимость: 

- ленивая инициализация (виртуальный прокси). Когда у вас есть тяжёлый объект, грузящий  данные из файловой системы или базы данных. 

-защита доступа (защищающий прокси). Когда в программе есть разные типы пользователей,  и вам хочется защищать объект от неавторизованного доступа. Например, если ваши объекты  — это важная часть операционной системы, а пользователи — сторонние программы  (хорошие или вредоносные). 

- локальный запуск сервиса (удалённый прокси). Когда настоящий сервисный объект  находится на удалённом сервере. 

- логирование запросов (логирующий прокси). Когда требуется хранить историю обращений  к сервисному объекту. Заместитель может сохранять историю обращения клиента к  сервисному объекту. 

Плюсы: 

- позволяет контролировать сервисный объект незаметно для клиента. - можно добавлять  несколько новых обязанностей сразу 

- может работать, даже если сервисный объект ещё не создан. 

- может контролировать жизненный цикл служебного объекта. 

Минусы: 

- усложняет код программы из-за введения дополнительных классов.- обилие крошечных  классов. 

- увеличивает время отклика от сервиса. 

Фасад (Facade) - предоставляет простой интерфейс к сложной системе классов, библиотеке  или фреймворку. 

Фасад используется для выделение только необходимых методов или свойств с других  библиотек.  

Применимость: 

- когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме. - когда вы хотите разложить подсистему на отдельные слои. 

Плюсы: 

- изолирует клиентов от компонентов сложной подсистемы. 

Минусы: 

- усложняет код программы из-за введения дополнительных классов.- обилие крошечных  классов. 

- Фасад рискует стать божественным объектом, привязанным ко всем классам программы. 

Мой личный пример на проекте(Facade):  

Для представления моделей в ПДФ используется View модели а для их рендера используется 

15 

using Microsoft.AspNetCore.Mvc.Razor;  

using Microsoft.AspNetCore.Mvc.Rendering; 

библиотеки. Из данных библиотек мне необходимы были определённые метода (RenderAsync  FindView) и создал класс RazorEngineFacade где написал метод рендера который возвращал  мне уже сгенерированную страницу в виде стринг. Таким образом я создал фасад над данными  библиотеками и использую только необходимые методы. 

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXdIZOPhG3GjY-efGA80qyzpLs7dbXucHNTQrf1PJcmkSadB7OrHwRQun_Z7Y8GaTjGhTqCNiE8LneAaHjc6WIie46FDtT-4W-AO--RM-pokyd5fPyUoyu7FyxZeDjczY3c-TYI5Rh4EKuBiiwF087Tu6oUj?key=yjRwXb7PJrHg8pl5IhCOAA)

16 

SOLID 

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXe3vQDvx4XhVGWExZhvgXzDQ2BQE-UUU8EROuFAxNuIWbHphusu17sZLmUViFuTpRsRtpsWSYg0GOSh2wzma8HOUpw0B_WcD3j0LxEZSqTO6W62hhRQnmbqRa7l1UkWFkZxlJFUkkxr_gzH-3lEun_-pnMe?key=yjRwXb7PJrHg8pl5IhCOAA)

Принцип единственной ответственности (Single-Responsibility Principle,  SRP) – у объекта должна быть только одна обязанность которая инкапсулирована в  классе. Должна быть только одна причина для изменения. 

Через класс должна происходить только одна ось изменений. 

Любой сложный класс должен быть разбит на несколько простых составляющих,  отвечающих за определенный аспект поведения. Это упрощает как понимание, так и  развитие класса в будущем. Простой класс с небольшим числом зависимостей легко  изменить независимо от того, сколько причин для изменения существует 

Изменения, вносимые в систему, также можно разделить на  

1) естественные, которые возникают из-за изменения бизнес-логики или требуемого  поведения  

2) случайные, которые мы вынуждены вносить во второстепенные модули из-за  неудачного дизайна 

Ось изменений – это классы и методы которые постоянно меняются. 

К пользовательского интерфейса, которые знают о бизнес-правилах или работают  напрямую с базой данных – нарушение SRP 

Анализ кода при SRP: 

1) Убираем ненужные обязанности. Первое, что нужно сделать, — это найти обязанности,  которые можно переложить на плечи вызывающего кода 

2) Анализируем разбиение ответственности на разные классы 

3) Поддержка тестов  

Типичные ошибки: 

1) смешивание логики с инфраструктурой.Должна быть возможность сосредоточиться на  бизнес-правилах, не обращая внимания на второстепенные инфраструктурные детали;

17 

2) слабая связность. Объект не является цельным и решает несколько несвязанных задач 3) выполнение нескольких несвязанных задач.Может быть цельным, но решать несколько  несвязанных задач (вычисление заработной платы и построение отчета) 4) решение задач разных уровней абстракции. Класс/метод не должен отвечать за задачи  разного уровня 

Важность принципа единственной обязанности резко возрастает при увеличении  сложности. Если решение перестает помещаться в голове, то пришло время разбить его  на более простые составляющие, каждая из которых будет решать лишь одну задачу. 

Принцип«открыт/закрыт» » (Open-Closed Principle, OCP) - программные  сущности (классы, модули, функции и т. п.) должны быть открытыми для расширения, но  закрытыми для модификации 

Смысл принципа OCP: дизайн системы должен быть простым и устойчивым к изменениям. Э то значит, что, когда требования изменятся (не «если», а именно «когда»),  вы должны быть к этому готовы 

Во-первых, за счет абстракции и инкапсуляции. Выделение существенных (важных)  частей системы в открытой части класса позволяет сосредоточиться на важных аспектах  поведения, не задумываясь о реализации, скрытой от клиентов в закрытой его части. 

Во-вторых, за счет наследования. Выделение интерфейсов и абстрактных классов  позволяет думать о задаче еще более абстрактно. Полиморфное поведение позволяет  заменить один вариант реализации на другой во время исполнения, а также позволит  использовать повторно значительные фрагменты кода 

Типичные примеры нарушения: 

1) интерфейс класса является нестабильным. Постоянные изменения интерфейса класса,  используемого во множестве мест, приводят к постоянным изменениям во многих  частях системы 

Выводы  

Что такое OCP? Фиксация интерфейса класса/модуля и возможность изменения  реализации/поведения.  

Цели OCP: борьба со сложностью и ограничение изменений минимальным числом  модулей.  

Как мы реализуем OCP? С помощью инкапсуляции, которая дает возможность изменять  реализацию без изменения интерфейса, и посредством наследования, что позволяет  заменить реализацию, не затрагивая существующих клиентов базового класса. 

Принцип говорит, что класс должен не изменятся, но расширятся. К примеру, мы берём  класс, который уже покрыт тестами и стабильно работает с клиентом на прямую, чтобы 

18 

не изменять уже работающий класс мы создаём интерфейс между ним и клиентом, а  дальше можешь использовать разные подходы для его изменения тот же Декоратор или  Прокси  

Принцип подстановки Лисков (Liskov Substitution Principle, LSP) - дложна  быть возможность вместо базового типа подставить любой его подтип 

Если есть какой-то код куда приходит базовый класс, то в этот же его кусок кода должен  приходить без любых проблем(исключений) его любой наследник. 

Ещё другими словами: поведение наследников не должно противоречить поведению  заданном в базовом классе. Так же наследники не должен требовать от вызывающего кода  больше чем родитель и не предоставлять больше чем родитель. 

Должна существовать возможность использовать объекты производного класса вместо  объектов базового класса. Это значит, что объекты производного класса должны вести  себя согласованно, согласно контракту базового класса» 

Если мы закрываем/делаем неработоспособным один из методов базового класса мы  нарушаем LSP 

Обозначение нарушений: 

1) Производные классы используются полиморфным образом, но их поведение не  согласуется с поведением базового класса: генерируются исключения, не описанные  контрактом базового класса, или не выполняются действия, предполагаемые  контрактом базового класса. 

2) Контракт базового класса настолько нечеткий, что реализовать согласованное  поведение наследником просто невозможно. 

Пример нарушения:  

1) Если раньше код мог вызывать у родителя определённый метод, то если для  нормальной работы наследнику надо выполнить вызовы ещё каких-то методов, то код  нарушит LSP. 

2) Если код вызывает у наследника метод к примеру, для получения данных, который у  родителя работал нормально и возвращал что-то, а в наследника к примеру, вернётся  null это приведёт к ошибкам в будущем и нарушит LSP. 

Почему надо следовать: 

1) иерархии наследования приведут к неразберихе. Она будет заключаться в том, что  передача в метод экземпляра класса-наследника вызовет странное поведение  существующего кода; 

2) юнит-тесты базового класса никогда не будут проходить для наследников

19 

Пример: 

С точки зрения математики квадрат является прямоугольником, но у прямоугольника есть  высота и ширина, а у квадрата все стороны равны. При работе с клиентским кодом он  подразумевает, что высота и ширина независимы поля. Контракты этих двух фигур не  согласованы и могут привести к ошибкам.  

Мы можем не нарушать LSP если типы будут имутабельными.  

Пример с квадратами и прямоугольниками показал, что мы не можем доказать, нарушает  конкретный класс принцип подстановки Лисков или нет, пока не определимся с тем, чего  ожидают клиенты от поведения базового класса. 

Именно этой же логике следуют правила ковариантности и контравариантности  обобщений в языке C#. 

Так, именно отсутствие изменяемости позволяет трактовать объект IEnumerable<string>  как IEnumerable<object>. Поскольку мы можем лишь извлечь элемент из  последовательности и не можем поместить его обратно, то такое преобразование является  типобезопасным. 

Когда тип предназначен лишь для полиморфного использования, то такое наследование  является наследованием подтипов и должно соответствовать принципу подстановки  Лисков. Если же создание наследника нужно для повторного использования кода базового  класса или производный класс будет всегда использоваться напрямую, то вполне  возможно, что его интерфейс и контракт будут изменены: добавлены новые методы и/или  не реализованы некоторые методы базового класса 

Принцип разделения интерфейсов (Interface Segregation Principle, ISP) - клиенты не должны вынужденно зависеть от методов, которыми не пользуются 

Принцип разделения интерфейса предназначен для получения простого и слабо связного  кода. Он гласит, что клиенты должны зависеть лишь от тех методов, которые используют,  и не должны знать о существовании не интересующих их частей в интерфейсе  применяемых ими сервисов. Для получения простого в сопровождении кода каждый класс  должен знать минимум информации об окружающем коде, необходимой для решения  своей задачи 

Принцип разделения интерфейсов также соответствует одному из принципов  контрактного программирования: требуй меньше, но гарантируй больше. В терминах  контрактов это проявляется в виде использования более слабого предусловия и более  строгого постусловия. Чем проще аргументы метода, тем проще удовлетворять  предусловиям метода. На практике это правило выражается в использовании наиболее  простых типов, а также базовых типов в качестве входных аргументов 

Если интерфейс класса можно разбить на группу методов. Каждая группа предназначена  для обслуживания разных клиентов. Одним клиентам нужна одна группа методов, другим  - другая

20 

Следование принципу единственной обязанности приводит к связным (cohesive) классам,  что позволяет с меньшими усилиями их понимать и развивать. Следование принципу  разделения интерфейсов уменьшает связанность (coupling) между классами и их  клиентами, ведь теперь клиенты используют более простые зависимости, чем раньше. 

Еще один пример следования принципу разделения интерфейсов заключается в  использовании методов расширения. Вместо создания «жирного» интерфейса, которым  будет удобно пользоваться всем клиентам, можно выделить базовый интерфейс, а  вспомогательные методы реализовать в виде методов расширения. В этом случае базовый  интерфейс будет максимально простым и разные клиенты самостоятельно решат, какие  методы расширения использовать. 

Типичные примеры нарушения ISP: 

1) Метод принимает аргументы производного класса, хотя достаточно использовать  базовый класс. 

2) У класса два или более ярко выраженных вида клиентов. 

3) Класс зависит от более сложной зависимости, чем нужно: принимает интерфейс  провайдера вместо результатов его работы и т. П 

4) Класс зависит от сложного интерфейса, что делает его зависимым от всех типов,  используемых в этом интерфейсе 

Лишь по исходному коду класса или его интерфейса мы не можем судить о том, нарушает  он принцип разделения интерфейсов или нет. Для этого нужно посмотреть контекст его  использования: есть ли разные группы клиентов, которые используют его по-разному, или  нет. 

Если класс используется разными клиентами, это может говорить о слишком большом  числе обязанностей, поэтому его нужно упростить. В некоторых случаях у класса может  быть одна обязанность, которая рассматривается клиентами с разных точек зрения. Тогда  этот факт нужно сделать явным путем реализации двух или более интерфейсов. 

Принцип инверсии зависимостей (Dependency Inversion Principle, DIP) - 

Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и другие  должны зависеть от абстракций.  

Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций Совмещает OCP и LSP 

Использовать класс нужно только через интерфейс - спорно. 

Принцип инверсии зависимостей предназначен для устранения прямых связей между  классами или модулями с зависимостями более высокого уровня 

Примеры нарушения:

21 

1) Низкоуровневые классы напрямую общаются с высокоуровневыми классами — модели  знают о пользовательском интерфейсе или инфраструктурный код знает о бизнес логике. 

2) Классы принимают слишком низкоуровневые интерфейсы, такие как IFileStream, что  может привести к подрыву инкапсуляции и излишнему увеличению сложности. 

Принцип инверсии зависимости (Dependency Inversion Principle. DIP) говорит о том,  какого вида зависимости необходимо передавать классу извне, а какие зависимости класс  должен создавать самостоятельно. Важно, чтобы зависимости класса были понятны и  важны вызывающему коду. Зависимости класса должны располагаться на текущем или  более высоком уровне абстракции. Другими словами, не любой класс, которого требует  интерфейс в конструкторе, следует принципу инверсии зависимостей 

1) Single responsibility - объект, метод должны заниматься только одним своим делом, в  противоположность антипатерну God-object 

2) Open closed principle - для добавления новых функций не должно требоваться  изменять существующий код 

3) Liskov substitution - использовать базовый класс не зная о реализации наследника 4) Interface segregation principle - не раздувать интерфейсы 

5) Dependency inversion principle - вначале интерфейсы, потом реализация, но не  наоборот

22 

DDD(Domain-Driven Design) 

DDD — это подход к разработке программного обеспечения, ориентированного на бизнес. 

DDD помогает решить проблему построения сложных систем. Этот шаблон требует  области сначала точного понимания требований. Затем они определяют поведение,  понимают правила, применяют принципы и бизнес-логику в наборе предложений  (абстракции, интерфейсы и т. д.). 

Преимущества: 

1) Слабая связь. Части системы будут взаимодействовать друг с другом посредством  определений и принципов, заложенных на уровне ядра (интерфейсы, абстрактные  классы, базовые классы и т. д.). Реализации будут завершены на оставшихся слоях. 

2) Гибкость : свободные связи и высокоуровневые определения позволяют команде более  гибко расширять и адаптироваться к новым функциональным требованиям без  значительного влияния на систему в целом. 

3) Тестируемость : как упоминалось выше, при отделении реализации от интерфейсов,  определенных на уровне ядра, допускается тестирование с фиктивными данными в  отдельной среде. 

4) Обслуживание : DDD четко распределяет функции по слоям/уровням. В частности,  Домен реализует бизнес-логику, Инфраструктура отвечает за сохранение данных,  а Приложение обрабатывает API и логику интеграции. Следование этому подходу  в конечном итоге дает вам возможность писать более чистый и надежный код. Кроме  того, ваша команда может легко находить код, ограничивать его дублирование и  сокращать время обслуживания. 

Недостатки: 

1) Знание предметной области : DDD требует обширного знания предметной области. 2) Низкое взаимодействие : слабая связь между различными частями требует, чтобы  команда регулярно общалась и обменивалась информацией. 

3) Затраты на разработку : Эксперты предметной области и команда должны реализовать  большую изоляцию и инкапсуляцию в рамках модели предметной области. 

Архитектура проектов DDD обычно включает три основные части:  

1) Домен 

2) Инфраструктура 

3) Приложение. 

Домен - место для определения логических концепций, принципов, шаблонов и поведения  данных, включая проверку домена, вычисления и выражения для системных операций. 

1) Сущности: классы POCO, построение и проверка модели. 

2) Совокупность: правила, вычисления, логика доменов и связанные объекты при  обновлении домена.

23 

3) Объекты-значения: значение объекта, связанного с объектами домена. 4) Интерфейсы: они помогают определить бизнес-поведение 

5) Интерфейсы репозитория/ServiceBase: интерфейсы общих репозиториев, репозиториев  доменов и служб. 

Приложение – мобильное приложение, веб-сайт, другие сервисы 

Инфраструктура: 

1) Репозитории: здесь будут реализованы репозитории, включая GenericRepository и  <Entity> Repository. 

2) Доступ к данным: контексты и соединения API связаны с базами данных. a. SQL: ADO.NET, EntityFramework, Dapper, ORM и т. д. 

b. Кэширование, NoSQL и так далее. 

3) Логирование и тд. 

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXeRwnuuOSoLUOyq2k2wWLF49ig3aMco7jmv-kNSNVMhdfbtFetTUj1qZ3cF5WrCHH0WL0VPjSxxfgxq1oTlKaRUx0WPIKSIO9Xh3_QBDZjhbfyAVkTqtDVW7VR7bl1wvBkQrtSKPNd5aGe9LFC2N3gHuu0S?key=yjRwXb7PJrHg8pl5IhCOAA)

Уровень API(приложение) - это прикладной уровень, который работает как шлюз, где  приложения взаимодействуют с системой. Этот уровень обрабатывает собранную  информацию о взаимодействиях между приложением и конечными пользователями или  сторонними службами. Он получает запросы и проверяет ввод перед отправкой их в домен  для обработки. API также предоставляет ответы клиенту. 

Хранит: DTO, Endpoints, Extension, Application services 

Слой домена – это центр системы. Домен обрабатывает большую часть бизнес-логики  системы. Этот слой также отвечает за определение концепций, поведения и правил. 

Хранит: доменные модели, енамы, обишки, логирование, интерфесы как репозиторий,  юнит оф ворк 

Уровень инфраструктуры - инфраструктура системы включает в себя базу данных,  журналирование и исключения. Этот слой является местом для взаимодействия с базой  данных. С помощью поведения и правил классы POCO были определены в Домене. На  этом уровне выполняются все операции, связанные с хранением информации в системе. 

Домен относится к конкретному предмету, для которого разрабатывается проект. Домен – это сущность для которой пишем бизнес логику

24**